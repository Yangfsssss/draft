"use strict";
/** Chapter3：代码的坏味道 */
//我们并不试图给你一个何时必须重构的精确衡量标准。从我们的经验看来，没有任何量度规矩比得上见识广博者的直觉。
//我们只会告诉你一些迹象，它会指出“这里有一个可以用重构解决的问题”。
//你必须培养自己的判断力，学会判断一个类内有多少实例变量算是太大、一个函数内有多少行代码才算太长。
//3.1 神秘命名（Mysterious Name）-------------------------------------------------------------------------------------------------------
//改名不仅仅是修改名字而已。如果你想不出一个好名字，说明背后很可能潜藏着更深的设计问题。
//为一个恼人的名字所付出的纠结，常常能推动我们对代码进行精简。
//3.2 重复代码（Duplicated Code）--------------------------------------------------------------------------------------------------------
//如果你在一个以上的地点看到相同的代码结构，那么可以肯定：设法将它们合而为一，程序会变得更好。
//一旦有重复代码存在，阅读这些重复的代码时你就必须加倍仔细，留意其间细微的差异。
//如果要修改重复代码，你必须找出所有的副本来修改。
//最单纯的重复代码就是“同一个类的两个函数含有相同的表达式”。
//这时候你需要做的就是采用提炼函数（106）提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码。
//如果重复代码只是相似而不是完全相同，请首先尝试用移动语句（223）重组代码顺序，把相似的部分放在一起以便提炼。
//3.3 过长函数（Long Function）-----------------------------------------------------------------------------------------------------------
//据我们的经验，活得最长、最好的程序，其中的函数都比较短。
//每当感觉需要以注释来说明点什么的时候，我们就把需要说明的东西写进一个独立函数中，并以其用途（而非实现手法）命名。
//我们可以对一组甚至短短一行代码做这件事。哪怕替换后的函数调用动作比函数自身还长，
//只要函数名称能够解释其用途，我们也该毫不犹豫地那么做。
//关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。
//条件表达式和循环常常也是提炼的信号。你可以使用分解条件表达式（260）处理条件表达式。
//对于庞大的 switch 语句，其中的每个分支都应该通过提炼函数（106）变成独立的函数调用。
//如果有多个 switch 语句基于同一个条件进行分支选择，就应该使用以多态取代条件表达式（272）。
//至于循环，你应该将循环和循环内的代码提炼到一个独立的函数中。
//如果你发现提炼出的循环很难命名，可能是因为其中做了几件不同的事。
//如果是这种情况，请勇敢地使用拆分循环（227）将其拆分成各自独立的任务
//3.4 过长参数列表（Long Parameter List）----------------------------------------------------------------------------------------------
//如果可以向某个参数发起查询而获得另一个参数的值，那么就可以使用以查询取代参数（324）去掉这第二个参数。
//如果你发现自己正在从现有的数据结构中抽出很多数据项，就可以考虑使用保持对象完整（319）手法，直接传入原来的数据结构。
//如果有几项参数总是同时出现，可以用引入参数对象（140）将其合并成一个对象。
//如果某个参数被用作区分函数行为的标记（flag），可以使用移除标记参数（314）。
//使用类可以有效地缩短参数列表。如果多个函数有同样的几个参数，引入一个类就尤为有意义。
//你可以使用函数组合成类（144），将这些共同的参数变成这个类的字段。
//如果戴上函数式编程的帽子，我们会说，这个重构过程创造了一组部分应用函数（partially applied function）。
//3.5 全局数据（Global Data）--------------------------------------------------------------------------------------------------------------
//首要的防御手段是封装变量（132），每当我们看到可能被各处的代码污染的数据，这总是我们应对的第一招。
//你把全局数据用一个函数包装起来，至少你就能看见修改它的地方，并开始控制对它的访问。
//随后，最好将这个函数（及其封装的数据）搬移到一个类或模块中，只允许模块内的代码使用它，
//从而尽量控制其作用域。
//3.6 可变数据（Mutable Data）-------------------------------------------------------------------------------------------------------------
