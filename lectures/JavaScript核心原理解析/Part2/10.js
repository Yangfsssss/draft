/**10| x = yield x：迭代过程的“函数式化” */
//还是回到函数的三个语义组件，也就是“参数、执行体和结果”来讨论。
//上一讲本质上讨论的是对“执行体”这个组件的重造，今天，则讨论对“参数和结果”的重构。

function ten() {
  //将迭代过程展开-----------------------------------------------------------------------------------------------------
  function test() {
    //迭代函数foo()，当你把它作为对象 x 的迭代器符号名属性，并通过对象 x 来调用它的迭代展开，
    //事实上也就相当于只调用了多次的 return 语句。
    function foo(x = 5) {
      return {
        next: () => {
          return { done: !x, value: x && x-- };
        },
      };
    }

    let x = new Object();
    x[Symbol.iterator] = foo;
    console.log(...x);
  }

  // test()
  //事实上连续的 tor.next() 调用最终仅是为了获取它们的值（result.value），
  //那么如果封装这些值的生成过程，就可以用一个新的函数来替代一批函数。
  //这样的一个函数就称为生成器函数。

  //但是，由于函数只有一个出口（RETURN），所以用“函数的退出”是无法映射
  //“函数包含一个多次生成值的过程”这样的概念的。
  //如果要实现这一点，就必须让函数可以多次进入和退出。

  //而这，就是今天这一讲的标题上的这个yield 运算符的作用。
  //这些作用有两个方面：
  //1，逻辑上：它产生一次函数的退出，并接受下一次 tor.next() 调用所需要的进入；
  //2，数据上：它在退出时传出指定的值（结果），并在进入时携带传入的数据（参数）。

  //所以，yield实际上就是在生成器函数中用较少的代价来实现一个完整“函数执行”过程所需的“参数和结果”。
  //执行体就是 tor.next() 所推动的那个迭代逻辑。

  //生成器的实现
  function test1() {
    function* foo() {
      yield 5;
      yield 4;
      yield 3;
      yield 2;
      yield 1;
    }

    //或者
    function* foo2(x = 5) {
      while (x--) yield x;
    }

    let x = new Object();
    x[Symbol.iterator] = foo2;
    console.log(...x);
  }

  test1();
  //我们又看到了循环，尽管它被所谓的生成器函数封装了一次。

  //逻辑的重现-------------------------------------------------------------------------------------------------------------
  
}

ten();
