/** 09，(...x)：不是表达式、语句、函数，但它却能执行 */

//语句执行和函数执行是对顺序、分支与循环三种逻辑在语义上的表达。

//参数、执行体和结果
//通过改造这三个语义组件的不同部分，我们可以得到不同的“函数式的”执行特征与效果。
//换而言之，可以通过更显式的、特指的或与应用概念更贴合的语法来表达新的语义。
//与所谓“特殊可执行结构”一样，这些语义也用于映射某种固定的、确定的逻辑。
//语言的设计，本质就是为确定的语义赋以恰当的语法表达。

// 递归与迭代--------------------------------------------------------------------------------------------
//在函数执行中为循环设计合适的语法表达：
// 1，递归：
// 递归将循环的次数直接映射成函数“执行体”的重复次数，将循环条件放在函数的参数界面中，
//并通过函数调用过程中的值运算来传递循环次数之间的数值变化。
function test() {
  const f = (x: number): number => x && f(--x);

  console.log(f(5));
}

//递归并不改变函数的三个语义组件中的任何一个，因此它与函数执行过程完全没有冲突。
// 递归不需要任何特殊的语法和运算 / 操作符，
// 它只是对函数、（变量或常量的）声明、表达式以及函数调用等等的简单组合。
// 函数的三个语义组件都不需要为此作出任何的设计修改。
// test();

// 2，迭代：
// 迭代说明循环是“函数体”的重复执行，而不是“递归”所理解的“函数调用自己”的语义。
//这是一种可受用户代码控制的循环体。
function test1() {
  function foo(x = 5): Iterator<number> {
    return {
      next: () => {
        return { done: !x, value: x && x-- };
      },
    };
  }

  const iterator = foo();
  console.log(iterator.next());
  console.log(iterator.next());
  console.log(iterator.next());
  console.log(iterator.next());
  console.log(iterator.next());
  console.log(iterator.next());
  console.log(iterator.next());
}

//在这个迭代函数中有“值 (value) 和状态 (done)”两个控制变量，
// 并且它的实际执行代码与上面的函数 f() 是一样的。

//递归函数“f()”和迭代函数“foo()”其实是在实现相同的过程。
// 只是由于“递归完成与循环过程的结束”在这里是相同的语义，
// 因此函数“f()”中不需要像迭代函数那样来处理“状态 (done)”的传出。
// 递归函数“f()”，要么结束，要么无穷递归。
// test1();

// 迭代对执行过程的重造和使用-----------------------------------------------------------------------
//在 JavaScript 中，是通过一个中间对象来使用迭代过程 _foo()_ 的。
//该中间对象称为迭代器，foo() 称为迭代器函数，用于返回该迭代器。

//如果有一个对象“包含”这样一个迭代器函数（以返回一个迭代器），那么这个对象就是可迭代的。

//展开语法------------------------------------------------------------------------------------------------
// ...x既不是表达式，也不是语句。它不是我们之前讲过的任何一种概念，而仅仅只是“语法”。
//作为语法，ECMAScript 在这里规定它只是对一个确定的语义的封装。
//在语义上，它用于“展开一个可迭代对象”。

//内部迭代过程-------------------------------------------------------------------------------------------
function test2() {
  function touch(x) {
    if (x === 2) throw new Error('hard break');
  }

  // 迭代函数
  function foo2(x = 5) {
    return {
      next: () => {
        touch(x);
        return { done: !x, value: x && x-- };
      },
    };
  }

  let x = new Object();
  x[Symbol.iterator] = foo2;

  console.log(...x);
}

test2();
