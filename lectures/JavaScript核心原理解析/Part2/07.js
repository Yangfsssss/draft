/** 07，`${1}`：详解JavaScript中特殊的可执行结构 */

//模板是一种特殊的可执行结构。

//参数表也是一种特殊的可执行结构。
//参数表把参数放在 arguments 列表中，然后让 arguments 中的值与参数表中的名字对应起来。
//箭头函数也是采用与上述过程完全一致的处理逻辑，只是在最后没有向闭包绑定 arguments 这个名字。
//简单参数，就是可以在形式参数表中可以明确数出参数个数的、没有使用扩展风格声明参数的参数表。

//扩展风格的参数表：
//缺省参数是一种可执行结构，是参数表作为可执行结构的逻辑中的一部分。
//剩余参数和参数展开都具有类似的性质，也都是参数表作为可执行结构的逻辑中的一部分。

//赋值模板
//只要语义是“向左操作数（lhs）上的标识符，赋以右操作数（rhs）的值”，那么它就适用于模板赋值。

//所有这些地方的赋值模板，都是在语法解析期就被分析出来，并在 JavaScript 内部作为一个可执行结构存放着。
//然后在运行期，会用它们来完成一个“从右操作数按模板取值，并赋值给左操作数”的过程。
//这与将函数的参数表作为样式（Formal）存放起来，然后在运行期逐一匹配传入值是异曲同工的。

//所有这些执行的结果都是一个名字，执行的语义就是给这个名字一个值。
//显然这是不够的，因为除了给这个名字一个值之外，最终还得使用这个名字以便进行更多的运算。
//那么，这个“找到名字并使用名字”的过程，就称为“发现（Resolve binding）”，而其结果，就称为“引用（reference）”。

//任何的名字，以及任何的字面量的值，本质上都可以作为一个被发现的对象，并且在实际应用中也是如此。
//在代码的语法分析阶段，发现一个名字与发现一个值本质上没有什么不同。

//“发现的结果——引用（Reference）”，也就不是简单的一个语法标识符，而是一个可执行结构了。

//属性引用（Property Reference）
//属性引用不是简单的标识符引用，而是一个属性存取运算的结果。
//所以，表达式运算的结果可以是一个引用。
//它是为数不多的、可以存储原表达式信息，并将该信息“传递”到后续表达式的特殊结构。
//严格地说，所有的引用都可以设计成这个样子，只不过属性引用是我们最常见到的罢了。

//引用作为函数调用（以及其它某些运算）的“左操作数（lhs）”时，是需要传递上述信息的。
//这也就是“引用”这种可执行结构的确定逻辑。

//本质上来说，它就是要帮助 JavaScript 的执行系统来完成“发现 / 解析（Resolve）”过程，
//并在必要时保留这个过程中的信息。在引擎层面，如果一个过程只是将“查找的结果展示出来”，
//那么它最终就表现为值；如果包括这个过程信息，通常它就表现为引用。

//模板字面量
//模板字面量是一种可执行结构。JavaScript 中有许多类似的可执行结构，
//它们通常要用固定的逻辑，并在确定的场景下，交付 JavaScript 的一些核心语法的能力。

//与参数表和赋值模板有相似的地方，模板字面量也是将它的形式规格（Formal）作为可执行结构来保存的。
//只是参数表与赋值模板关注的是名字，因此存储的是“名字（lhs）”与“名字的值（rhs）的取值方法”之间的关系，
//执行的结果是 argArray 或在当前作用域中绑定的名字等。
//而模板字面量关注的是值，它存储的是“结果”与“结果的计算过程”之间的关系。
//由于模板字面量的执行结果是一个字符串，所以当它作为值来读取时，就会激活它的运算求值过程，并返回一个字符串值。

//模板字面量的内部结构中，主要包括将模板多段截开的一个数组，原始的模板文本（raw）等等。
//在引擎处理模板时，只会将该模板解析一次，并将这些信息作为一个可执行结构缓存起来（以避免多次解析降低性能），此后将只使用该缓存的一个引用。
//当它作为字面量被取值时，JavaScript 会在当前上下文中计算各个分段中的表达式，并将表达式的结果填回到模板从而拼接成一个结果，最后返回给用户。
