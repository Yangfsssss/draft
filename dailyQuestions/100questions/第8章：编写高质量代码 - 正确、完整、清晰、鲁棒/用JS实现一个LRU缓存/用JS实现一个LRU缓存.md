什么是LRU缓存？
    LRU - Least Recently Used 最近使用；
    如果内存有限，只缓存最近使用的，删除“沉水”数据；
    两个核心API：get，set；

分析：
    用哈希表存储数据，这样get/set才够快O(1);
    必须是有序的，常用数据放在前面，“沉水”数据放在后面；
    哈希表 + 有序，就是Map --- 其他都不行。
    object无序，也不可排序；
    array有序，也可排序，但效率低；
    Set有序，但不可排序；

划重点：
    如果面试时你不知道LRU（或其他名词），你可以问面试官。
    考虑功能，更考虑性能。
    选择合理数据结构。

连环问：如何不用Map实现LRU缓存？
    LRU使用Map是基于两个特点：
        哈希表（get/set速度快）；
        有序；
    
    可以结合Object + Array实现这两点；

    但依然存在性能问题：Array操作慢：
        移除“沉水”数据，用数组shift效率太低；
        get/set时移动数据，用数组splice效率太低；

    把数组改为双向链表：
        可快速增加元素；
        可快速删除元素；
        可快速移动元素位置；

划重点：
    数据结构设计：data和list分别存储什么；
    双向链表的操作非常繁琐，代码很容易写错，不易调试；
    链表node要存储node.key，否则需要遍历删除；
